3 first-fit

I am maintaining four variables in a structure called "heap_info". These are the number of blocked allocated (int blocks_allocated), Maximim size of chunk (int max_chunk), Minimum size of chunk (int min_chunk) and current allocated size (int curr_size). 
On calling the function my_alloc(), blocks_allocated is incremented by 1 each time. Similarly the size of allocated memory (curr_size) is incremented by (sizeof(header)+requested_size). Max chunk size is updated only when the chunk returned by the first fit approach, correspondeds to the max chunk. Its only in this case that the entire free list is iterated. On the contrary, in order to update the min chunk size, we need to iterate through the free list each time. This is because the during memory allocation, either the size of the node decreases or is completely deleted. 
Similarly, while executing the function my_free(), The max chunk size is updated only if the size of the newly inserted free node or the coalesced size of the free node is more than the max size. In any of the cases, there is no need for list traversal. If the 'to be freed' pointer corresponds to the min sized chunk, its size might increase in case of coalescing. Hence, we need to traverse the free list to update the min chunk size. Similarly since the min chunk size is the least positive available space, if the size of the 'to be freed' node (before coalescing) is zero, the list needs to be traversed. If the freed node doesn't undergo any coalescing in the free list, size of the newly created node is compared with the current max and min size and updated accordingly. 
Note:: We keep an extra variable named "extra_size" of type "long-long (8 bytes)" in header_t of allocated memory. This extra size is needed to make sizeof(header_t)== sizeof(node_t).  If the sizes are unequal, then on free(), the pointers might get over-written and lead to wrong outputs.